---
title: 数据库索引设计与优化-2表和索引结构
cover_img: 'http://qiniucdn.timilong.com/1551521095956.jpg'
date: 2019-07-04 12:47:49
tags: 数据库
feature_img: 
description: 数据库索引设计与优化
keywords: 数据库
categories: 数据库
---

![cover_img](http://qiniucdn.timilong.com/1551521095956.jpg)

> 转载自: [数据库索引设计与优化-2表的索引和结构](https://www.yuque.com/jzqt/xq88yc/zb9spc)

讨论索引设计之前，我们需要先理解 索引 和 表 是如何使组织和使用的。当然具体实现很大程度上取决于具体的关系型 DBMS，不过它们依赖的结构和原则都大致相似。


表和索引行都被放在 页 中，页大小一般是 <b>4 KB</b>（现在的 DBMS 页大小默认值一般都设置得会比这个大）。
不过在索引设计中这不是个很重要的考虑点，页大小仅仅决定一个页可以存储多少索引行、表行，以及需要多少页来存储表或者索引。

每个页一般都会预留一定比例的空闲空间，用来满足添加新的表行或索引行的需求。


## 索引行及索引结构

对于一个 唯一索引 ，比如一张表上的主键索引，一个索引行就是叶子页上的一个 索引条目 。 索引条目由 索引字段值 和一个 指针 构成。叶子页 的指针指向表中的记录，通常 表页的编号 以及 表行在表页的位置 会是这个指针的组成部分。 非叶子页 的指针指向下一层索引页，存储的索引键值是对应指向下一层索引页中的最大键值（笔者注：也可能是最小，这不重要，重要的是顺序存储）。

![002](http://qiniucdn.timilong.com/mysql_002.png)

对于一个 非唯一索引 ，一个特定索引值对应的索引行应该被 想象 成独立的索引条目，每一个（指前面被想象成的独立索引条目）都包含相同的索引值，但对应不同的指针。大部分情况下非唯一索引的实际存储方式是一个索引值带有多个指针。


## 表行

每一个索引行都指向数据表中对应的一行记录。表中的每一行除了会存储行的字段信息之外，还会包括一些控制信息。

表中记录的顺序可以被定义成和某个索引一样的顺序。这样的话，索引行按照顺序处理时，对应的表行也是按照顺序处理的，这会是一个很高效的过程。

如果表行的顺序和索引的顺序不一致。比如，第一条索引记录指向表页 17，下一条索引记录指向的是表页 2，再下一条指向表页 85。这样的话，即使索引处理依然是顺序高效，但是表记录的访问却是随机且低效的。

## 缓冲池和磁盘 I/O

关系型数据库系统会使用内存中的缓冲池来尽可能确保数据随时可用，避免不必要的磁盘读。这个策略对 SQL 语句执行的性能至关重要，索引页或表页在不在缓冲池中，访问的成本是不同的。

## 磁盘驱动器的随机 I/O


![003](http://qiniucdn.timilong.com/mysql_003.png)

书中给出等待一个页从磁盘读取到缓冲池中的一个理想估算时间是 10 ms。不管你需要这个页上的所有行，部分行或者某一行数据，读取花费的成本是相同的。下面按照书中所说给出 10 ms 这个数据是如何得出的。

| 操作 | 时间 | 描述 |
| :--: | :--: | :--: |
| 排队  | 3 ms  | 取决于磁盘驱动器繁忙度 |
| 寻道  | 4 ms  | 服务时间 | 
| 半圈旋转  | 2 ms  |  | 
| 传输  | 1 ms | | 
| 总 I/O 时间  | 10 ms |

> 注：所有列出的数据根据不同的实际情况中都会所变化，列出数据只是为了让读者有一个相对的概念。数据是死的。


## 磁盘服务器缓存的读取

现在的磁盘服务器都有提供自己的内存（或缓冲区），就像数据库缓冲池一样，磁盘服务器会试图将频繁读取的数据保留在内存（或缓冲区）中，从而降低高昂的磁盘读成本。

![005](http://qiniucdn.timilong.com/mysql_005.png)

当一个索引页或者表页被请求时，它的最理想位置应该是在 `数据库缓冲池` 中。
如果不在那里，它的下一个最佳位置应该是在 `磁盘服务器的读缓冲区` 中。
如果也不在这里，那就只能冲磁盘中进行一次很慢的读取，这个过程有可能需要花费很长时间来等待磁盘设备空闲。


## 磁盘驱动器的顺序读取

前面只考虑了将一个索引页或表页读取到缓冲池的情况。很多实际场景下，我们需要将多个页读取到缓冲池中并按顺序处理它们。DBMS 能识别出那些不在缓冲池的页（在缓冲池的页可能包含尚未被写入磁盘的更新数据），发出多页 I/O 请求，每次请求的页的数量由 DBMS 决定。

同时读取多个页有以下两个很重要的优势：

- 同时读取多个页意味着平均读取每个页的时间将会减少。（比如 4 KB 大小的页，读取时间可能降低至 0.1ms，基于 40 MB/s 的磁盘读速度计算）
- DBMS 事先知道需要读取哪些页，会在页被真正请求前就将其读取出来，我们称之为 预读 。


## 辅助式随机读


除了数据库缓冲池和磁盘缓冲区来降低随机读取的成本，还有其他一些场景也能降低该成本。有些是自然发生的，有些是优化器有意为之。书中将下面这些机制统称为 `辅助式随机读` 。


## 自动跳跃式顺序读

顾名思义，`一系列不连续的行按照同一个方向扫描`，那么访问模式即为 `跳跃式顺序的` 。
这样的话每行平均 I/O 时间会比随机访问要短。跳跃距离越短，节省时间越多。

一般当表行通过一个聚簇索引读取时，访问模式即为跳跃式顺序的。



跳跃式顺序读的好处会在下面两种情况下被放大：

- 磁盘服务器注意到对某一驱动器的访问是顺序的（或者几乎是顺序的），于是开始向前提前读取多个页。
- DBMS 注意到 SELECT 语句以顺序的（或者几乎是顺序的）访问索引或表页，于是开始向前提前读取多个页。（在 DB2 for z/OS 中被称为动态预读）


## 列表预读

前面由于表和索引行的访问顺序是一致的，因此很容易地通过跳跃式顺序读获得了成本降低的收益。而 `列表预读` 则是在`表和索引行访问顺序不一致`的情况下，`主动创造跳跃式顺序访问`。
为了做到这点，它需要访问所有满足条件的索引行，然后按照表页顺序进行排序后再访问表行。

![006](http://qiniucdn.timilong.com/mysql_006.png)

上面是传统索引扫描的示例图，黑色圆圈里的数字代表读取的顺序。作为对比，下面给出使用 列表预读 的示例图。

![007](http://qiniucdn.timilong.com/mysql_007.png)


## 数据块预读

表行和索引行访问顺序不一致时，Oracle 会使用 数据块预读 这一特性。这一特性会先从索引片上收集指针，然后再进行多重随机 I/O 来并行地读取表行。

![008](http://qiniucdn.timilong.com/mysql_008.png)

> 注：考虑到查询的结果集被获取的顺序，一个索引也许可以自动提供正确顺序，但是上面讨论的辅助式随机读的一些机制也许会破坏索引提供的顺序，这时候还需要对查询的结果集进行一次排序。

## 辅助式顺序读

当需要扫描一张大表的时候，优化器可能会选择开启 `并行` 机制。比如将一个游标拆分成多个范围谓词限定的游标，每一个游标各自扫描一部分索引。这样的话，当有多个处理器或磁盘驱动器可用时，所花费的时间就会相应地减少。

## 同步 I/O 和异步 I/O

同步 I/O 指在进行 I/O 操作时，DBMS 不能进行其他操作，必须等待直到 I/O 操作完成。
在一次 `同步读` 操作中，我们必须先定位到我们所需的行，然后再开始读取对应的页，读取完毕后才处理该行。每一步都必须等待上一步完成。

![009](http://qiniucdn.timilong.com/mysql_009.png)

`异步读` 则是在当前一步的页还在处理时就被提前发起了，这一步的处理时间和异步读的时间会有很大一部分重叠。理想的情况是准备处理异步读的页之前，异步读就已经完成。每一组页都以这种方式被预读然后再开始处理。

> 注意：整个预读过程会先从一次同步读开始，然后再开始预读过程。

![010](http://qiniucdn.timilong.com/mysql_010.png)

大部分数据库写是异步的，为了达到对性能影响的最小化。这样做的主要影响是加重了磁盘负载，反过来会影响读的性能。


## DBMS 特性

### 页

表页大小限制了表行的最大长度。通常，一个表行必须能够存入一个表页中，一个索引行页必须能够存入一个叶子页中。

如果表平均行长度大于表页大小的三分之一，空间利用率会很糟糕。这种空间利用率问题对于索引来说更加严重，索引的叶子页应该有能够容纳多个索引行的空闲空间（`为了方便添加新的索引行而不造成叶子页分裂`），如果索引行长度大于叶子页大小的 20%，就有可能造成糟糕的空间利用率，以及频繁地叶子页分裂。

### 表聚簇

通常一个表页中只包含一张数据表的数据。Oracle 支持在一个表页交错存储多个相关数据表的数据。比如，一个表页存储着一个用户数据表的数据以及相关联的 4 张其他数据表数据，这样的话读取某个用户及其关联数据只需要一次 I/O 操作而非 5 次。

> 笔者注：这个特性我们在实际开发中几乎没有遇到，书中也只是举了 Oracle 提供一个选项支持的例子，同时也指出交错存储多张表可能会引起其他方面的一些问题。

### 索引组织表

如果表行不是特别长，可以考虑将表上所有列都放在索引上，`索引的叶子页会用来存储表行`，来加快 `SELECT` 的执行速度。这样的话表就冗余了。

在 Oracle 中这个选项被称为 `索引组织表` ，它使用`主键索引`来存储表行。而在 SQLServer 中，使用选项 `CLUSTERED` 来创建这样一个存储表行的索引（SQLServer 称为聚集索引）。上面的环境下，其余索引（Oracle 中称为次级索引，SQLServer 中称为非聚集索引）都指向包含表行的那个索引。

> 注：没有特别指明，默认情况下只讨论主键索引作为聚集索引。

索引组织表的明显好处：

- 节省磁盘空间
- 插入、删除和更新的操作速度更快（应该是相对于索引本身要更新的情况，可以少更新一个表页，因为索引叶子页本身即表页）

不过索引组织表给其他索引带来了一些坏处。如果其他索引使用直接指向表行的指针（指针包含页号），那么主键（聚集）索引的一次叶子页分裂会导致其他索引上大量的磁盘 I/O（因为需要更新表行指针的页号）。

为了避免这一坏处，DBMS 一般会把主键索引的索引键来作为其他索引的指针值。不过这样做也带来一些问题，主要就是从其他索引（非聚集索引）来访问表会涉及两组非叶子页读取（一次非聚集索引，一次聚集索引）。不过这个额外负载不是主要问题，因为非叶子页是被缓存在缓冲池的。

SQLServer 中并不是只能设置 `主键索引` 为 `聚集索引` 。但是为了降低 `非聚集索引` 的指针维护成本，一般会选择一个键值不会被更新的索引作为聚集索引。

笔者注： 索引组织表 主要是 Oracle 的说法，对于 MySQL InnoDB 使用 聚簇索引 这个说法，两者都是同样用来描述索引存储表行这一存储形式。

### 页邻接

逻辑上相邻的页如果在物理上也是相邻的，那么顺序读将会非常快（下面三个级别中的级别 2）。

1. 读取一个页，得到许多行（如果 4KB 大小的页包含 10 行记录，I/O 时间大约为 1ms 每行）
2. 读取一个磁轨，得到许多页（可能将顺序 I/O 时间降低至 0.1ms 每行）
3. 磁盘服务器提前从驱动器上读取数据到读缓冲区中（可能将顺序 I/O 时间降低至 0.01ms 每行）


## B 树索引的替代品

### 位图索引

位图索引由针对不同列值（或真值表达式）的位图组成。每一个位图中，表中每一行对应一个位，如果该行满足条件，该位被置为 1。

对于 `复杂不可预测` 的组合谓词的大表查询，适合用位图索引。使用位图索引进行 `与` 和 `或` 的位运算非常快。

![011](http://qiniucdn.timilong.com/mysql_011.png)

满足以下条件下适合使用位图索引：

- 谓词组合数量太多，以至于设计足够多的 B 树索引不可行
- 单个谓词有很高的过滤因子，组合起来之后具有很低的过滤因子，或者 SELECT 列表中只包含 COUNT 
- 更新操作是批量进行的（不存在锁争用）

### 散列

即哈希索引，适合已知键值的情况下读取一个表行的最快方式，原理与哈希表相同。不赘述。
