---
title: 数据库索引设计与优化-1索引
cover_img: 'http://qiniucdn.timilong.com/'
date: 2019-07-04 12:43:13
tags:
feature_img:
description:
keywords:
categories:
---

![cover_img]()

不合适的索引


多年来，不合适的索引通常是造成 SQL 性能低下的最常见原因。最普遍的情况有



没有索引足够多的列来支持 WHERE 子句中的条件表达式
索引了正确的列，但是索引列顺序不对
SELECT 子句没能包含有效的索引


关系型数据库中，改进索引一般相对容易，因为不需要对应用代码做任何修改。

但是在生产环境中改动总会带来风险，而且，创建索引时，更新操作可能会经历长时间等待，比如无法更新为了创建索引而正在被扫描的表。



笔者注：现在的关系型数据库比如 MySQL、PostgreSQL 等都支持在不阻塞更新操作时修改或增加索引，但索引期间仍然会影响更新操作的执行时间。



误区和误解


有些书会认为通常 B 树索引只有 根页 会留在内存中。三十年前这可能是一个合理的假设，因为当时的内存很小（可能小到不及 1 MB），而今天的内存甚至能达到 GB 级别，磁盘读缓存一般就更大了（比如 64 GB）。现在完全可以假设 B 树索引的所有 非叶子页 通常会留在内存或者读缓存中，一般只有叶子页需要从磁盘中读取。



类似的假设导致了许多过时和危险的建议，比如



误区一：索引层级不要超过 5 层


注：这里说的索引层级指的就是 B 树索引的层数。



这个建议会在某些关系型文献出现，通常就是基于 只有根页会留在内存中 的假设。



每个索引层级会向索引扫描过程贡献约 50 微妙（μs），非叶子页如果不在内存而在磁盘读缓存中，读取索引页可能会花费 1 毫秒（ms）。用这些值和一次磁盘随机读取花费的时间（大约 10 ms）做比较。下面以拥有 1 亿行数据，6 个索引层级，行平均长度为 100 字节，1 个叶子页包含 35 个索引行的索引为例简单说明：



image.png



根据上面的图推导出如下结论



该索引有大约 3 000 000 个 4 KB 大小的页，约占 12 GB 磁盘空间
叶子页总大小（2 900 000 × 4 KB）几乎占满 12 GB 空间，合理的假设是这部分数据通常会从磁盘读取（10 ms）
叶子页的上一层级大小约为 83 000 × 4 KB，约占 324 MB。如果该索引被频繁使用，即使不在数据库缓冲池（比如 4 GB 内存），也可以能会留在磁盘读缓存（可能是 64 GB）
再上一层级的大小约 2 400 × 4 KB，约占 10 MB，几乎肯定会在数据库缓冲池中


那么，访问这个 6 层索引的 1 亿行数据中任意一个索引行，将花费 10～20 ms，即使索引行加入的顺序杂乱无章，这个数字也是对的。因此对索引层数做限制并没有什么意义。



笔者注：一般来说索引层数与索引行数以及索引行长度有关。最初我错误地以为索引层数只跟索引行数有关，那么限制索引层数实际上就是限制数据条目数，这样的话这个限制跟对索引如何设计貌似没有什么参考价值。

实际上，索引层数还跟索引行长度有关，行长度越大，一个索引页能包含的索引行越少，需要的索引页越多，自然索引层数也越多，访问索引需要读取磁盘次数也越多。

那么，对于限制索引层级，我的理解是，相同索引层级下，数据量小，则允许索引行大，即可索引列数越多，数据量大则限制其索引行大小，即允许索引的列越少。



误区二：单表索引数不要超过 6 个


笔者注：书中并没有举例解释为什么单表索引数不要超过 6 个，实际上它反驳给单表索引数设置上限的观点，并支持这样一种观点：因为限制单表索引个数往往会导致绝大部分 SQL 运行良好，但少数 SQL 执行起来很糟糕。而保证所有 SQL 都能够流畅运行是设计的底线，为了达到这一点需要在表上建几个索引，那就应该建几个索引。



误区三：不应该索引不稳定的列


索引行是按照索引键的顺序存储，所以当索引键中有一列被更新，那么数据库需要把相应的行从旧的位置移到新的位置。如果新旧位置在同一个页中，这种情况更新一个页即可，如果不在同一个页，则需要更新两个页。



几十年前，如果这个索引是一个 4 层索引，那么更新一个索引列也许需要 6 次磁盘读取（这里是基于前面说的 只有根页会留在内存中 的假设），其中 3 次常规读取，即 2 次非叶子页和 1 次叶子页读取，以及新位置涉及的 3 次随机读取。当一次随机读取耗时 30 ms（这里和前面所说的磁盘随机读取耗时约 10 ms 不一样，毕竟书上说的是几十年前，磁盘比现在慢些也正常），迁移一个索引行可能会花费 6 × 30 = 180 ms 的时间。这种情况，不稳定列不推荐索引就不足为奇了。



而现在，4 层索引的 3 层非叶子页在内存中，一次磁盘随机读需要 10 ms，更新索引行的响应时间变成了 2 × 10 = 20 ms。如果更新后不是迁移到新叶子页，响应时间会降低到 10 ms。



当前磁盘条件下，更新频率多余 10 次/秒的情况下，不稳定列才可能成为问题，不过这样的列并不常见。



笔者注：总之，书中认为现在的磁盘等硬件性能比以前要好得多，虽然这些硬件性能仍然限制了我们能索引的条目数上限等，但这个上限会比以前高得多。



系统化的索引设计


索引设计方法首次尝试源于 20 世纪 60 年代。那时有一种 列活动矩阵模型方法 ，用来预测每个字段的读取和更新频率，以及字段所在行的的插入和删除频率。该模型能帮助人们找到需要被索引的字段的列表。通常这些索引都被假定只包含一个字段，来减少磁盘 I/O 的数量。



20 世纪 80 年代， 面向列的索引设计方式 开始落后于 面向响应时间的索引设计方式 。DBA 们开始意识到，创建索引的目的应该是在硬件容量限制的前提下保证所有数据库调用运行得足够快。



书中所说 系统化的索引设计 包含两个步骤：



找到当前索引条件下运行过慢的查询，至少是在最差输入条件下运行过慢的查询（比如【最大的客户】、【最老的日期】等）
设计索引使找到的慢查询变得足够快，且不导致其他 SQL 调用明显变慢


很长一段时间来，系统化索引设计的第二步都未被认可。教材和课程的 SELECT 语句一般都非常简单以致于很容易就设计出最佳索引。然而实际经验表示即使看起来无害的 SELECT 语句，通常也有大量合理的索引设计方式。估算每种索引方式都花太多精力和时间，即使经验丰富的数据库设计者凭直觉来设计也会放一些错误。这就是我们为什么需要一个算法来为给定的 SQL 设计最佳索引的原因。



