---
title: 读书笔记-推特主页时间线设计与实现
date: 2018-09-07 15:14:56
tags: 设计数据密集型应用
cover_img: http://qiniucdn.timilong.com/1543736955437.jpg
feature_img:
description: 在讨论增长问题（如果负载加倍会发生什么？）前，首先要能简要描述系统的当前负载。负载可以用一些称为负载参数（load parameters）的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景。
keywords: 系统设计
categories: 读书笔记
---

> 转载自: [设计数据密集型应用 - 中文翻译](https://legacy.gitbook.com/book/vonng/ddia-cn/details)

### 描述负载

在讨论增长问题（如果负载加倍会发生什么？）前，首先要能简要描述系统的当前负载。负载可以用一些称为负载参数（load parameters）的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景。

为了使这个概念更加具体，我们以推特在2012年11月发布的数据【16】为例。推特的两个主要业务是：

#### 发布推文
用户可以向其粉丝发布新消息（平均 4.6k请求/秒，峰值超过 12k请求/秒）。

#### 主页时间线
用户可以查阅他们关注的人发布的推文（300k请求/秒）。

处理每秒12,000次写入（发推文的速率峰值）还是很简单的。然而推特的扩展性挑战并不是主要来自推特量，而是来自扇出（fan-out）——每个用户关注了很多人，也被很多人关注。

> 扇出：从电子工程学中借用的术语，它描述了输入连接到另一个门输出的逻辑门数量。 输出需要提供足够的电流来驱动所有连接的输入。 在事务处理系统中，我们使用它来描述为了服务一个传入请求而需要执行其他服务的请求数量。 

大体上讲，这一对操作有两种实现方式。

### 实现方式1: 拉模型

![http://qiniucdn.timilong.com/WX20180907-152712@2x.png](http://qiniucdn.timilong.com/WX20180907-152712@2x.png)

发布推文时，只需将新推文插入全局推文集合即可。当一个用户请求自己的主页时间线时，首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并。在如图所示的关系型数据库中，可以编写这样的查询：
```
 SELECT tweets.*, users.* 
   FROM tweets 
   JOIN users   ON tweets.sender_id = users.id 
   JOIN follows ON follows.followee_id = users.id 
   WHERE follows.follower_id = current_user
```

### 实现方式2: 推模型
![http://qiniucdn.timilong.com/111111.png](http://qiniucdn.timilong.com/111111.png)

为每个用户的主页时间线维护一个缓存，就像每个用户的推文收件箱如上图所示。 当一个用户发布推文时，查找所有关注该用户的人，并将新的推文插入到每个主页时间线缓存中。 因此读取主页时间线的请求开销很小，因为结果已经提前计算好了。 

### 推拉结合
推特的第一个版本使用了方法1，但系统很难跟上主页时间线查询的负载。

所以公司转向了方法2，方法2的效果更好，因为发推频率比查询主页时间线的频率几乎低了两个数量级，所以在这种情况下，最好在写入时做更多的工作，而在读取时做更少的工作。

然而方法2的缺点是: 发推现在需要大量的额外工作。 平均来说，一条推文会发往约75个关注者，所以每秒4.6k的发推写入，变成了对主页时间线缓存每秒345k的写入。

但这个平均值隐藏了用户粉丝数差异巨大这一现实，一些用户有超过3000万的粉丝，这意味着一条推文就可能会导致主页时间线缓存的3000万次写入！及时完成这种操作是一个巨大的挑战 —— 推特尝试在5秒内向粉丝发送推文。

在推特的例子中，每个用户粉丝数的分布（可能按这些用户的发推频率来加权）是探讨可扩展性的一个关键负载参数，因为它决定了扇出负载。你的应用程序可能具有非常不同的特征，但可以采用相似的原则来考虑它的负载。

推特轶事的最终转折：
现在已经稳健地实现了方法2，推特逐步转向了两种方法的混合。
大多数用户发的推文会被扇出写入其粉丝主页时间线缓存中。但是少数拥有海量粉丝的用户（即名流）会被排除在外。当用户读取主页时间线时，分别地获取出该用户所关注的每位名流的推文，再与用户的主页时间线缓存合并，如方法1所示。

这种混合方法能始终如一地提供良好性能。在[第12章](https://vonng.gitbooks.io/ddia-cn/ch12.html) 中我们将重新讨论这个例子，这在覆盖更多技术层面之后。 
